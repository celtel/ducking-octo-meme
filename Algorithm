\documentclass{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{perpage} 
\MakePerPage{footnote}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\title{Paxos-like implementions in SDN transactions}
\author{John Smith}
\date{Aprilis 2015}
\begin{document}
   \maketitle
   \textbf{DON'T WORRY! EVERYTHING GONNA BE OK}\\
It's better to start from the beginning and to see the things as easy as possible.\\
\textbf{What do we assume in this model?}\\ The SDN model of \emph{data} and \emph{control planes}: 
\begin{enumerate}
\item Distributed(multiple entities named \emph{controllers}), failure-prone(some \emph{controllers} may crash - stop functioning), asynchronous (eventually synchronous) \emph{data plane}
\item static topologically \emph{data plane}
\item transactional interface - ack/nack (implmented thanks to the OpenFlow)
\item Consensus objects (exists thanks to the implementation of CAS functionality \cite[Herlihy and Shavit], implemented in the FlowTables using invisible for packets \emph{tags} (header field of the packet))
\end{enumerate}
\textbf{Remark:} all the implementations will be built in time. We start with a model which assumes already the existence of these functionalities and we focus more on the core algorithm. Gradually we will introduce how the exact implementations imapct the pseudocode.\\
In R[0..N-1] we store the propositions from the controllers from 0 to N-1. R[i] can be empty. In \emph{linearized} we store the policies already put in the C[0] to C[k] objects, k grows. All R, k, and \emph{linearized} are local for each contorller and are updated thanks to the information exchange with \emph{data} and \emph{control plane}.\\
\textbf{What does the controller when it receives a request from the client?}
\begin{enumerate}
\item it checks whether $\pi$ proposed is not in conflict with what is installed
\item If it is, then reject($\pi$, \emph{reason}), where \emph{reason} may contain some information useful for the demanding application, but can be empty, too
\item Else send to all your $R_{updated}$, \emph{linearized} and k
\end{enumerate}
%\begin{enumerate}
%\item send to quroum ($\pi$, R[0..N-1],\emph{linearized}, k, ...)
%\item If received more than \emph{fastQuorumSize} of ack's send again ($R_{updated}$[0..N-1], $k_{updated}, linearized_{updated}$, ...) to all and wait for responses.
%\item if \emph{quorumSize} of ack's Then 
%\item send R[0..N-1] to C[k], for the "k" you've collected and install($\pi$)
%\item if the C[k] is already occupied send info to the $leader_\pi$
%\item two variants: 1. leader repeats k++ $\&$ send R[0..N-1] to C[k] until it gets the msg is saved in some C[k] 2. the swicth itself knows how to search for the next free C[k] and once it's found the msg that R is in some C[k] is sent to the leader(may be sent to all). 
%\item linearized = linearized $\cup$ {all the C[k] we didin't know up to the k we have received now}
%\item Else 
%\end{enumerate}
\textbf{What does the controller when it receives a request from it's peer?}
\begin{enumerate}
\item $linearized_{mine}$  update  with $linearized_{received}$ and k (how to implement?)
\item $R_{mine}[0..N-1] = R_{received}[0..N-1]$ - \emph{$ linearized_{mine} $} 
\item if $\pi_{proposed}$ is not in conflict send \emph{ack} with R and \emph{linearized} and k
\item else send \emph{nack} with R and \emph{linearized}
\end{enumerate}
 \textbf{What does the leader on receiving a response from the quorum?}
\begin{enumerate}
\item If ack and if (++nbAck $>=$ \emph{fastQuorumSize}) Then 
\item update \emph{linearized} set, R and k
\item send to all R, \emph{linearized} and new status of $\pi$
\item collect the repsponses from all, once it's done \emph{install($\pi$)} on the \emph{data plane}, send the R[0..N-1] to C[k]
\item Else send again to all R,k,\emph{linearized} with info I was nacked and wait for at least $\ceil{N/2}$ other controllers
\item once it's received run lines 3. and 4.
\item end if 
\item expect the confirmation of the accomplished installation
\end{enumerate}
\textbf{Remark1:} In fact, after receiving a nack before having nbAck$>$= \emph{fastQuorumSize} we don't need to send put the line 5 and 6, because no matter what we will get as an answer, we will have to inform the quorum about the R vector. \\
After collecting all the data we should inform the \emph{data plane} about the new installations to be performed.\\
\textbf{Remark2:} in fact, we don't need the quorum to decide but only to collect the information, so the ack/nack received from there doesn't mean to much, only it gives us the information about what are the conflicting with $\pi$ policies, so we can use this information while choosing which policy to install. So this remark implies that \\
\textbf{What does the leader with the collected information?}
\begin{enumerate}
\item send R to C[k]
\item wait for the notification
\end{enumerate}
\textbf{Remark:} We the C[k] object should now decide what to do if it rejects some transatctions. Namely, it should either take care by itself of finding some C[k'] object which would be free and would retrun ack for the transaction, or it sends directly the nack to the leader$_\pi$ and it is the controller to send the R vector to C[k+1] until it receives an ack from some C[k']
Once it is done we 
How might work the \emph{consensus object C}? In this case?
We use the atomic CAS implementation for each C[k], which means, once the batch or R[0..N-1] arrives to the C[k] in one atomic step it undertakes the CAS\\
Once the batch,\emph{i.e.}, $R_\pi$ arrives: 
\begin{enumerate}
\item if CAS($\emptyset$,R) Then send notification to the leader
\item else switch takes care of finding the right switch with C[k'] free(we leave it in a \emph{black box})\footnotemark; once the switch receives the batch and the CAS returns true it sends a notification to the leader$\pi$ and sends to all(any change on the switch is signalized to the \emph{control plane} thanks to the \emph{OpenFlow} 1.4. standards) the ordered policies.
\footnotetext{We can also just send the notification to the $leader_\pi$ that there is no place in C[k]}
\end{enumerate}
\textbf{The next question is how does the C[k] order the incoming updates in batches?}\\
 We need to introduce here a \emph{lexicographical} order: $(nb_{acc}, id_1 )<(nb_{acc'}, id_2)$  \textbf{iff}  $nb_{acc} < nb_{acc}'  $ \emph{or} $nb_{acc} = nb_{acc}'$ and $id_1<id_2$, where $nb_{acc}$ means the number of already installed policies by the controller with id = $id_k$.
 The consensus can also look on the conflicts among the policies in its own batch, but as it's unaware of what is installed and what's the content of each C[k'] before him then it cannot decide by himself what will be the exactly installed and leaves this work for the \emph{data plane}. However, it'll be now the task of the \emph{control plane}.\\
 Once the \emph{data plane} receives the notifications from C[0] to some C[k], it can easily count what should be installed and if it should install  its own policy, if it's the leader of some.\\
 \textbf{How do we decide what to install?}\\
 Let $\pi_1<\pi_2<\pi_3<...<\pi_n$ will be sequence collected by a controller from C[0] up to some C[k]. We assume here silently that we always have that C[k]$<$C[k+1] for all k=0,1,... .
And now $\pi_l$ is installed if it composes with what has been installed before, meaning there are now conflicts between $\pi_{i_1}\circ...\circ \pi_{i_j}$, where $\circ$ stands for the composition of the policies.
 
\end{document}
