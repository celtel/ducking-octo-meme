\documentclass{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{perpage} 
\MakePerPage{footnote}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\title{Paxos-like implementions in SDN transactions}
\author{John Smith}
\date{Aprilis 2015}
\begin{document}
   \maketitle
   \textbf{DON'T WORRY! EVERYTHING GONNA BE OK}\\
It's better to start from the beginning and to see the things as easy as possible.\\
\textbf{What do we assume in this model?}\\ The SDN model of \emph{data} and \emph{control planes}: 
\begin{enumerate}
\item Distributed(multiple entities named \emph{controllers}), failure-prone(some \emph{controllers} may crash - stop functioning), asynchronous (eventually synchronous) \emph{data plane}
\item static topologically \emph{data plane}
\item transactional interface - ack/nack (implmented thanks to the OpenFlow)
\item Consensus objects (exists thanks to the implementation of CAS functionality \cite[Herlihy and Shavit], implemented in the FlowTables using invisible for packets \emph{tags} (header field of the packet))
\end{enumerate}
\textbf{Remark:} all the implementations will be built in time. We start with a model which assumes already the existence of these functionalities and we focus more on the core algorithm. Gradually we will introduce how the exact implementations imapct the pseudocode.\\
In R[0..N-1] we store the propositions from the controllers from 0 to N-1. R[i] can be empty. In \emph{linearized} we store the policies already put in the C[0] to C[k] objects, k grows. All R, k, and \emph{linearized} are local for each contorller and are updated thanks to the information exchange with \emph{data} and \emph{control plane}.\\
\textbf{What does the controller when it receives a request from the client?}
\begin{enumerate}
\item it checks whether $\pi$ proposed is not in conflict with what is installed
\item If it is, then reject($\pi$, \emph{reason}), where \emph{reason} may contain some information useful for the demanding application, but can be empty, too
\item Else send to all your $R_{updated}$, \emph{linearized} and k
\end{enumerate}
%\begin{enumerate}
%\item send to quroum ($\pi$, R[0..N-1],\emph{linearized}, k, ...)
%\item If received more than \emph{fastQuorumSize} of ack's send again ($R_{updated}$[0..N-1], $k_{updated}, linearized_{updated}$, ...) to all and wait for responses.
%\item if \emph{quorumSize} of ack's Then 
%\item send R[0..N-1] to C[k], for the "k" you've collected and install($\pi$)
%\item if the C[k] is already occupied send info to the $leader_\pi$
%\item two variants: 1. leader repeats k++ $\&$ send R[0..N-1] to C[k] until it gets the msg is saved in some C[k] 2. the swicth itself knows how to search for the next free C[k] and once it's found the msg that R is in some C[k] is sent to the leader(may be sent to all). 
%\item linearized = linearized $\cup$ {all the C[k] we didin't know up to the k we have received now}
%\item Else 
%\end{enumerate}
\textbf{What does the controller when it receives a request from it's peer?}
\begin{enumerate}
\item $linearized_{mine}$  update  with $linearized_{received}$ and k (how to implement?)
\item $R_{mine}[0..N-1] = R_{received}[0..N-1]$ - \emph{$ linearized_{mine} $} 
\item if $\pi_{proposed}$ is not in conflict send \emph{ack} with R and \emph{linearized} and k
\item else send \emph{nack} with R and \emph{linearized}
\end{enumerate}
 \textbf{What does the leader on receiving a response from the quorum?}
\begin{enumerate}
\item If ack and if (++nbAck $>=$ \emph{fastQuorumSize}) Then 
\item update \emph{linearized} set, R and k
\item send to all R, \emph{linearized} and new status of $\pi$
\item collect the repsponses from all, once it's done \emph{install($\pi$)} on the \emph{data plane}, send the R[0..N-1] to C[k]
\item Else send again to all R,k,\emph{linearized} with info I was nacked and wait for at least $\ceil{N/2}$ other controllers
\item once it's received run lines 3. and 4.
\item end if 
\item expect the confirmation of the accomplished installation
\end{enumerate}
\textbf{Remark1:} In fact, after receiving a nack before having nbAck$>$= \emph{fastQuorumSize} we don't need to carry out lines 5 and 6, because no matter what we will get as an answer, we will have to inform the quorum about the R vector. \\
After collecting all the data we should inform the \emph{data plane} about the new installations to be performed.\\
\textbf{Remark2:} in fact, we don't need the quorum to decide but only to collect the information, so the ack/nack received from there doesn't mean to much, only it gives us the information about what are the conflicting with $\pi$ policies, so we can use this information while choosing which policy to install. So this remark implies that we don't really need to wait for the whole quorum to respond. \textbf{But}, we can so as to collect more precise information from the quroum. Then the code in line 1 would be 1': If ++nbAswers $>$ \emph{expectedNumberOfAnswers} Then... \\
\textbf{What does the leader with the collected information?}
\begin{enumerate}
\item send R to C[k]
\item wait for the notification
\end{enumerate}
\textbf{Remark:} Now we should decide what the C[k] do if it rejects a transatction. Namely, should either take care by itself of finding some C[k'] object which would be free and would retrun ack for the transaction, or it sends directly the nack to the leader$_\pi$ and it is the controller to send the R vector to C[k+1] until it receives an ack from some C[k']
Once it is done we may continue with \emph{installation part}.\\
How might work the \emph{consensus object C}? In this case?
We use the atomic CAS implementation \cite[In-Band Synchronization] for each C[k], which means, once the vector R[0..N-1] arrives to the switch for C[k], in one atomic step, it executes the CAS method. \\
Once the vector,\emph{i.e.}, $R_\pi$ arrives: 
\begin{enumerate}
\item if CAS($\emptyset$,R) Then send notification to the leader
\item else switch takes care of finding the right switch with C[k'] free(we leave it in a \emph{black box})\footnotemark; once the switch receives the vector, and the CAS returns true it sends a notification to the leader$\pi$ and sends to all(any change on the switch is signalized to the \emph{control plane} thanks to the \emph{OpenFlow} 1.4. standards) the ordered policies.
\footnotetext{We can also just send the notification to the $leader_\pi$ that there is no place in C[k]}
\end{enumerate}
\textbf{Remark:} Try to find out the implementation of the above recipe using the OpenFlow 1.4., should be possible.\\
\textbf{The next question is how does the C[k] order the incoming updates in batches?}\\
 We need to introduce here a \emph{lexicographical} order: $(nb_{acc}, id_1 )<(nb_{acc'}, id_2)$  \textbf{iff}  $nb_{acc} < nb_{acc}'  $ \emph{or} $nb_{acc} = nb_{acc}'$ and $id_1<id_2$, where $nb_{acc}$ means the number of already installed policies by the controller with id = $id_k$.\\
 The feature each consensus object might possess: detect conflicts among the policies in the R vector it received(this can be done already by the controller on the \emph{control plane}), but as it's unaware neither of what is installed on the \emph{data plane} nor of the content of each C[k'] for k'$<$k.\\
 Once the leader$_\pi$ on the \emph{control plane} receives the notifications from C[0] to some C[k], it can easily count what should be installed. The roll-out of the installation: each contorller having gathered the notifications from C[0] to C[k], for some k, takes up the installation. Of each $\pi\in \cup_i C[i] $. Another \emph{remark} here is that during the message-passing the contorller can also exchange the knowledge about what is already installed on the \emph{data plane} (\textbf{Q? The OpenFlow provides the notificaiton about any change in switch status,\emph{i.e.}, installation or deletion/removal of a rule, so the knowledge in the CP is kept by this functionality}}) . The roll-out of the installation of the updates on the \emph{data plane} is to-be implemented(also here we can use CAS, I think). What's the picture now? All the contorllers try to install every composable policy on the \emph{data plane}. \textbf{Challenge:} diminish the number of installation attempts between CP and DP(to be continued and broaden, but the concept is already there). \\
 
 \textbf{How do we decide what to install?}\\
 Let $\pi_1<\pi_2<\pi_3<...<\pi_n$ will be sequence collected by a controller from C[0] up to some C[k]. We assume here silently that we always have that C[k]$<$C[k+1] for all k=0,1,... .
And now $\pi_l$ is installed if it composes with what has been installed before, meaning there are now conflicts between $\pi_{i_1}\circ...\circ \pi_{i_j}$, where $\circ$ stands for the composition of the policies.\\
\textbf{What's the roll-out of the installation?}\\
Once a controller (no matter if it's the leader or not) collects the notifications from C[0] to C[k], it acts according to the knowledge it has. It means, it installs only not yet installed policies. \textbf{How it's implemented?}\\
\begin{enumerate}
\item Send to all switches concerned by the updates the transactions containing new rules 
\item use CAS for 
\end{enumerate}
\end{document}
